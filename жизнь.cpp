#include <iostream>
#include <fstream>
#include <cstdlib>
#include <time.h>

using namespace std;

int main()
{
    //вводим переменные
    int counter = 1,num,counter2 = 0,counter3 = 0;
    char b,var;
    char present[21][21];
    char future[21][21];
    srand(time(0)); //привязываем генератор случайных чисел к консольному времени
    setlocale(LC_ALL, "Russian"); //локализируем консоль
    //создаём два файла на диске
    ofstream outfile("D://work.dat");
    ofstream outfile1("D://work.out");
    outfile1 << "Поколение №1" << endl; //вводим во второй файл название
    for (int c = 0;c<21;c++) //этими циклами генерируем символы в первом массиве 21х21
    {
    for(int a = 0;a<21;a++)
    {
        b = 33+rand()%4; //остаток можно изменять, но если добавлять больше различных символов, тем больше будет шанс на быстрое вымирание
        outfile << b << " "; //вводим символы в первый файл через пробел
        if(b==34) //выбираем допустим символ №34, и говорим, что это и есть микробы
            {
            present[c][a] = '1'; //заполняем символьный массив единицами на тех местах, где стоит 34 символ
            outfile1 << present[c][a]; //записываем массив во второй файл
            }
        else
            {
            present[c][a] = 0; //если этого символа нет, то в массив записываем не символьный нуль
            outfile1 << "-"; //а в файл знак '-'
            }
    }
    outfile1 << endl; //в конце каждой итерации второго цикла переходим на новую строку в обоих файлах
    outfile << endl;
    }
    outfile.close(); //закрываем файл с символами
    cout << "Введите количество поколений" << endl; //просим у пользователя ввод
    cin >> num;
    while(counter!=num) //тут в дело вступает первый счётчик, как только он достигнет числа, введённого пользователем, процесс генерирования поколений прекратится
    {
        counter += 1; //в начале каждой итерации переключаем счётчик
        outfile1 << "Поколение №" << counter << endl; //вводим номер поколения в файл
        for(int e = 0;e<21;e++) //основные два цикла, генерирующие поколения
        {
            for(int f = 0;f<21;f++)
            {
                if(present[e][f]!=0) //проверяем символьный массив на нули
                {
                    if(present[e][f+1]!=0&&present[e][f+1] != '0') //эти if-ы проверяют значения на "соседство"
                        counter3 += 1; //каждое такое "соседство" изменяет уже второй счётчик, когда значения счётчика 1, или 4, микроб умирает, если 2-3, то растёт
                    if(present[e][f-1]!=0&&present[e][f-1] != '0')
                        counter3 += 1;
                    if(present[e+1][f]!=0&&present[e+1][f] != '0')
                        counter3 += 1;
                    if(present[e-1][f]!=0&&present[e-1][f] != '0')
                        counter3 += 1;
                    if(present[e][f]=='0') //теперь проверяем на символьные нули, эти случаи возможны только начиная со второго поколения
                    {
                        if(counter3==2||counter3==3) //если есть соседи, то микроб будет расти
                            {
                        var = present[e][f]; //добавляем символьную переменную, чтобы не изменять значения текущего поколения
                        var++;
                        future[e][f] = var;
                        var = 0; //обнуляем переменную, она нам ещё понадобиться
                        outfile1 << future[e][f]; //записываем приравненное будущее число в файл
                        counter2+=1; //а тут уже приходит время третьего счётчика, если при окончании текущей итерации он так и останется нулевым, то это будет значить, что все микробы вымерли
                            }
                        else //если соседей нет, то он опять становится нулём
                            {
                            future[e][f] = '0';
                            outfile1 << future[e][f]; //записываем нуль в файл
                            }
                    }
                    else if(counter3==2||counter3==3) //если у любого элемента есть 2, или 3 соседа, то значит, что он не умрёт
                    {
                        var = present[e][f]; //опять используем эту же самую переменную
                        var++;
                        future[e][f] = var;
                        if(future[e][f]==':') //тут я немного изменил условия задачи, т.к. я использую символьный массив, то максимальный возраст было удобнее сократить с 12 до 9
                            future[e][f] = '0'; //микроб умирает и возраждается вновь
                        counter2 += 1; //опять тот самый третий счётчик
                        outfile1 << future[e][f]; //записываем число в файл
                        var = 0; //снова обнуляем переменную, для дальнейшего использования уже в следующей итерации
                    }
                    else //по сути нужно только для второго поколения, чтобы узнать, какие микробы умрут, в дальнейшем, они уже будут взаимодействовать через первый if
                    {
                        future[e][f] = '0'; //обнуляем элемент
                        outfile1 << future[e][f];  //записываем его в файл
                    }
                }
                else //этот else для всех поколений одинаковый - просто отвечает за проставление минусов в файле в тех местах, где микробы не водятся
                    {
                    future[e][f]=0; //добавляем не символьный нуль в следующее поколение
                    outfile1 << "-"; //а в файл записываем минус
                    }
                    counter3 = 0; //второй счётчик необходимо обнулять, после каждой итерации второго цикла
            }
            outfile1 << endl; //после каждой итерации второго цикла, переходим на другую строку
        }
        if(counter2 == 0) //проверка "есть ли кто живой?"
            {
                outfile1 << endl << "Поколение вымерло"; //если живых нет, сообщаем об этом в файле и прекращаем работу программы, т.к она бессмысленна
                outfile1.close(); //закрываем файл
                return 0;
            }
        for(int g = 0;g<21;g++) //ну а эти циклы отвечают за переход из будущего поколения в текущее
        {
            for(int h = 0;h<21;h++)
            {
                present[g][h] = future[g][h];
                future[g][h] = 0; //обязательно обнуляем значения будущего поколения
            }
        }
        //ну и в конце каждого поколения обнуляем оба счётчика
        counter2 = 0;
        counter3 = 0;
    }
    outfile1.close(); //как только основной цикл закончился, закрываем файл
    return 0;
}
