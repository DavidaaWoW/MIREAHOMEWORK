/*Плацкартный вагон. В плацкартном вагоне 54 места, пронумерованных числами от 1 до 54. Вагон разбит
на 9 купе. Первые 36 мест расположены по левую сторону от прохода, места 1–4 находятся
в первом купе, места 5–8 – во втором и т. д. В девятом купе находятся места с номерами 33–
36. По правую сторону от прохода находятся боковые места, их номера от 37 до 54, причём
они нумеруются в противоположном направлении: места 37 и 38 находятся напротив
девятого купе, а места 53 и 54 – напротив первого.
Группа школьников едет на олимпиаду и будет всю дорогу крутить спиннеры.
Поэтому им нужно купить места в нескольких подряд идущих купе вместе с прилегающими
боковыми местами. Даны номера свободных мест в поезде. Определите, какое наибольшее
число подряд идущих купе полностью свободны.
Программа получает на вход число N – количество свободных мест в вагоне
(0 ≤ N ≤ 54). Следующие N строк содержат номера свободных мест – различные числа от 1
до 54 в произвольном порядке, по одному числу в строке.
Программа должна вывести одно целое число – максимальное число подряд идущих
свободных купе (купе – 4 места слева от прохода и 2 боковых места) в этом вагоне.
*/
#include <iostream>
#include <algorithm>

using namespace std;

int section(int k)
{
    if(k<=36)
        {
        return (k-1)/4;
        }
    else
        return 8-(k-37)/2;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    cout << "Введите количество свободных мест в вагоне" << endl;
    int co[9] = {0,0,0,0,0,0,0,0,0};
    int sum = 0;
    int n;
    int c = 0,ans = 0;
    int *arr = new int[n];
    cin >> n;
    cout << "Вводите номера свободных мест" << endl;
    for(int a = 0;a<n;a++)
    {
        cin >> arr[a];
        co[a] = section(arr[a]);
        cout << co[a] << endl;
    }
    for(int i = 0;i<9;i++)
    {
        if(co[i] == 6)
            {
                ans += 1;
                ans = max(ans,c);
            }
            else
                ans = 0;
    }
    cout << ans;
    return 0;
}
/*Сначала нужно научиться по номеру свободного места определять номер купе, в
котором находится данное место. В приведенном ниже решении это делает функция section,
которая рассматривает два случая: номер места не превосходит 36 и номер места больше 36.
Создаётся массив count, где count[i] будет равно числу свободных мест в купе номер i.
Этот массив заполняется нулями, при считывании свободного места определяется номер
купе, в котором находится это место, и соответствующий элемент массива увеличивается
на 1.
После окончания считывания данных полностью свободные купе — это те купе, для
которых count[i] будет равно 6. Необходимо в массиве count найти самое большое число
подряд идущих элементов, равных 6 */
